package client

// DON'T EDIT THIS FILE is generated 2020-10-19 10:44:28.806207 +0000 UTC
// Mod crypto
// Crypto functions.
// Crypto functions.

type SigningBoxHandle struct {
	int `json:""`
}

type ParamsOfFactorize struct {
	// Hexadecimal representation of u64 composite number.
	Composite string `json:"composite"`
}

type ResultOfFactorize struct {
	// Two factors of composite or empty if composite can't be factorized.
	Factors []string `json:"factors"`
}

type ParamsOfModularPower struct {
	// `base` argument of calculation.
	Base string `json:"base"`
	// `exponent` argument of calculation.
	Exponent string `json:"exponent"`
	// `modulus` argument of calculation.
	Modulus string `json:"modulus"`
}

type ResultOfModularPower struct {
	// result of modular exponentiation
	ModularPower string `json:"modular_power"`
}

type ParamsOfTonCrc16 struct {
	// Input data for CRC calculation. Encoded with `base64`.
	Data string `json:"data"`
}

type ResultOfTonCrc16 struct {
	// Calculated CRC for input data.
	Crc int `json:"crc"`
}

type ParamsOfGenerateRandomBytes struct {
	// Size of random byte array.
	Length int `json:"length"`
}

type ResultOfGenerateRandomBytes struct {
	// Generated bytes, encoded with `base64`.
	Bytes string `json:"bytes"`
}

type ParamsOfConvertPublicKeyToTonSafeFormat struct {
	// Public key.
	PublicKey string `json:"public_key"`
}

type ResultOfConvertPublicKeyToTonSafeFormat struct {
	// Public key represented in TON safe format.
	TonPublicKey string `json:"ton_public_key"`
}

type KeyPair struct {
	// Public key. Encoded with `hex`.
	Public string `json:"public"`
	// Private key. Encoded with `hex`.
	Secret string `json:"secret"`
}

type ParamsOfSign struct {
	// Data that must be signed.
	// Must be encoded with `base64`.
	Unsigned string `json:"unsigned"`
	// Sign keys.
	Keys KeyPair `json:"keys"`
}

type ResultOfSign struct {
	// Signed data combined with signature. Encoded with `base64`.
	Signed string `json:"signed"`
	// Signature. Encoded with `base64`.
	Signature string `json:"signature"`
}

type ParamsOfVerifySignature struct {
	// Signed data that must be verified.
	// Must be encoded with `base64`.
	Signed string `json:"signed"`
	// Signer's public key.
	// Must be encoded with `hex`.
	Public string `json:"public"`
}

type ResultOfVerifySignature struct {
	// Unsigned data.
	// Encoded with `base64`.
	Unsigned string `json:"unsigned"`
}

type ParamsOfHash struct {
	// Input data for hash calculation. Encoded with `base64`.
	Data string `json:"data"`
}

type ResultOfHash struct {
	// Hex-encoded hash of input `data`.
	Hash string `json:"hash"`
}

type ParamsOfScrypt struct {
	// The password bytes to be hashed.
	// Must be encoded with `base64`.
	Password string `json:"password"`
	// A salt bytes that modifies the hash to protect against Rainbow table attacks.
	// Must be encoded with `base64`.
	Salt string `json:"salt"`
	// CPU/memory cost parameter
	LogN int `json:"log_n"`
	// The block size parameter, which fine-tunes sequential memory read size and performance.
	// 8 is commonly used
	R int `json:"r"`
	// Parallelization parameter.
	P int `json:"p"`
	// Intended output length in octets of the derived key.
	DkLen int `json:"dk_len"`
}

type ResultOfScrypt struct {
	// Derived key. Encoded with `hex`.
	Key string `json:"key"`
}

type ParamsOfNaclSignKeyPairFromSecret struct {
	// secret key
	Secret string `json:"secret"`
}

type ParamsOfNaclSign struct {
	// Data that must be signed. Encoded with `base64`.
	Unsigned string `json:"unsigned"`
	// Signer's secret key.
	Secret string `json:"secret"`
}

type ResultOfNaclSign struct {
	// Signed data, encoded with `base64`.
	Signed string `json:"signed"`
}

type ParamsOfNaclSignOpen struct {
	// Signed data that must be unsigned. Encoded with `base64`.
	Signed string `json:"signed"`
	// Signer's public key.
	Public string `json:"public"`
}

type ResultOfNaclSignOpen struct {
	// Unsigned data, encoded with `base64`.
	Unsigned string `json:"unsigned"`
}

type ResultOfNaclSignDetached struct {
	// Hex encoded sign.
	Signature string `json:"signature"`
}

type ParamsOfNaclBoxKeyPairFromSecret struct {
	// Hex encoded secret key.
	Secret string `json:"secret"`
}

type ParamsOfNaclBox struct {
	// Data that must be encrypted. Encoded with `base64`.
	Decrypted   string `json:"decrypted"`
	Nonce       string `json:"nonce"`
	TheirPublic string `json:"their_public"`
	Secret      string `json:"secret"`
}

type ResultOfNaclBox struct {
	// Encrypted data. Encoded with `base64`.
	Encrypted string `json:"encrypted"`
}

type ParamsOfNaclBoxOpen struct {
	// Data that must be decrypted. Encoded with `base64`.
	Encrypted   string `json:"encrypted"`
	Nonce       string `json:"nonce"`
	TheirPublic string `json:"their_public"`
	Secret      string `json:"secret"`
}

type ResultOfNaclBoxOpen struct {
	// Decrypted data. Encoded with `base64`.
	Decrypted string `json:"decrypted"`
}

type ParamsOfNaclSecretBox struct {
	// Data that must be encrypted. Encoded with `base64`.
	Decrypted string `json:"decrypted"`
	Nonce     string `json:"nonce"`
	Key       string `json:"key"`
}

type ParamsOfNaclSecretBoxOpen struct {
	// Data that must be decrypted. Encoded with `base64`.
	Encrypted string `json:"encrypted"`
	Nonce     string `json:"nonce"`
	Key       string `json:"key"`
}

type ParamsOfMnemonicWords struct {
	// dictionary identifier
	Dictionary *int `json:"dictionary,omitempty"`
}

type ResultOfMnemonicWords struct {
	// the list of mnemonic words
	Words string `json:"words"`
}

type ParamsOfMnemonicFromRandom struct {
	// dictionary identifier
	Dictionary *int `json:"dictionary,omitempty"`
	// mnemonic word count
	WordCount *int `json:"word_count,omitempty"`
}

type ResultOfMnemonicFromRandom struct {
	// string of mnemonic words
	Phrase string `json:"phrase"`
}

type ParamsOfMnemonicFromEntropy struct {
	Entropy    string `json:"entropy"`
	Dictionary *int   `json:"dictionary,omitempty"`
	WordCount  *int   `json:"word_count,omitempty"`
}

type ResultOfMnemonicFromEntropy struct {
	Phrase string `json:"phrase"`
}

type ParamsOfMnemonicVerify struct {
	// phrase
	Phrase string `json:"phrase"`
	// dictionary identifier
	Dictionary *int `json:"dictionary,omitempty"`
	// word count
	WordCount *int `json:"word_count,omitempty"`
}

type ResultOfMnemonicVerify struct {
	// flag indicating the mnemonic is valid or not
	Valid bool `json:"valid"`
}

type ParamsOfMnemonicDeriveSignKeys struct {
	// phrase
	Phrase string `json:"phrase"`
	// derivation path, for instance "m/44'/396'/0'/0/0"
	Path *string `json:"path,omitempty"`
	// dictionary identifier
	Dictionary *int `json:"dictionary,omitempty"`
	// word count
	WordCount *int `json:"word_count,omitempty"`
}

type ParamsOfHDKeyXPrvFromMnemonic struct {
	// string with seed phrase
	Phrase string `json:"phrase"`
}

type ResultOfHDKeyXPrvFromMnemonic struct {
	// serialized extended master private key
	Xprv string `json:"xprv"`
}

type ParamsOfHDKeyDeriveFromXPrv struct {
	// serialized extended private key
	Xprv string `json:"xprv"`
	// child index (see BIP-0032)
	ChildIndex int `json:"child_index"`
	// indicates the derivation of hardened/not-hardened key (see BIP-0032)
	Hardened bool `json:"hardened"`
}

type ResultOfHDKeyDeriveFromXPrv struct {
	// serialized extended private key
	Xprv string `json:"xprv"`
}

type ParamsOfHDKeyDeriveFromXPrvPath struct {
	// serialized extended private key
	Xprv string `json:"xprv"`
	// derivation path, for instance "m/44'/396'/0'/0/0"
	Path string `json:"path"`
}

type ResultOfHDKeyDeriveFromXPrvPath struct {
	// derived serialized extended private key
	Xprv string `json:"xprv"`
}

type ParamsOfHDKeySecretFromXPrv struct {
	// serialized extended private key
	Xprv string `json:"xprv"`
}

type ResultOfHDKeySecretFromXPrv struct {
	// private key
	Secret string `json:"secret"`
}

type ParamsOfHDKeyPublicFromXPrv struct {
	// serialized extended private key
	Xprv string `json:"xprv"`
}

type ResultOfHDKeyPublicFromXPrv struct {
	// public key
	Public string `json:"public"`
}
